<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[koorchik's blog]]></title>
  <subtitle><![CDATA[Programming and IT-business]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.koorchik.com//"/>
  <updated>2015-07-04T14:43:53.000Z</updated>
  <id>http://blog.koorchik.com//</id>
  
  <author>
    <name><![CDATA[Viktor Turskyi]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Language Independent Validation Rules]]></title>
    <link href="http://blog.koorchik.com/livr/index.html"/>
    <id>http://blog.koorchik.com/livr/index.html</id>
    <published>2015-07-04T13:18:53.000Z</published>
    <updated>2015-07-04T14:43:53.000Z</updated>
    <content type="html"><![CDATA[<p>Every programmer faced the need to validate user input. Doing web development for over 10 years, I have tried a lot of libraries, but did not find that one that would solve my goals.</p>
<h2 id="Main_issues_that_validation_libraries_have">Main issues that validation libraries have</h2><p><strong>Problem N1.</strong> A lot of validators validate only the data that has validation described. So, if there are some fields without validation they will be passed to the application. Such behavior is not acceptable. Validator must cut all the data without described validation rules. Any input which is not allowed must be ignored.</p>
<p><strong>Problem N2.</strong> Procedural description of validation rules. I do not want to think about the algorithm of validation  every time. I just want declarative description of the rules. In fact, I want to describe a schema. (why not “JSON Schema” - at the end of the post).</p>
<p><strong>Problem N3.</strong> Description of the validation rules in the form of code. It would seem that it’s not so bad, but it just negates all attempts to serialize the validation rules and use the same validation rules on the backend and frontend.</p>
<p><strong>Problem N4.</strong> Validation stops on the first error. Such approach makes it impossible to highlight all the error fields at once.</p>
<p><strong>Problem N5.</strong> Non standartised error codes. For example, “Field ‘name’ is required”. There are situations when such error cannot be used:</p>
<ul>
<li>the field can have different name in user interface</li>
<li>user interface can be in another language</li>
<li>we should be able to distinguish between error types. Fore example, for empty fields there can be another field highlighting</li>
</ul>
<p>So, validator should return not messages but error codes. </p>
<p><strong>Problem N6.</strong> Numeric error codes. It’s just inconvenient to use. I want the error codes to be intuitive. Agree that the error code “REQUIRED” is clearer than the code “27”. The logic is similar to working with classes of exceptions.</p>
<p><strong>Problem N7.</strong> No support for hierrarchical data structures.  Nowdays, when diferent JSON API are very popular, you cannot do your work without it. Morever, except validation the validator should return error codes pointing to fields in nested data structures.  </p>
<p><strong>Problem N8.</strong> Limit number of validation rules. It is always not enaugh built-in validation rules. A validator should be extensible and should allow you to add own rules of any complexity.</p>
<p><strong>Problem N9.</strong> Too broad scope of responsibility. The validator should not generate form, should not generate the code, should not do anything except validation.</p>
<p><strong>Problem N10.</strong> Inability to perform additional processing. Almost always, where there is a validation, there is a need for some additional data (pre|post)processing: remove the forbidden symbols, convert to lowercase, trim. Trimming spaces is especially important, in 99% of cases they are not needed. <em>I know that I had previously said that the validator should not do anything but validation.</em></p>
<p>3 years ago, it was decided to write a validator that will not have all of the problems. So there LIVR (Language Independent Validation Rules) appeared. There are a lot of implementation for different languages (Perl, PHP, JavaScript, Python). The validator is used in production for several years in almost every project of the company. The validator works both on the server and on the client.  You can play with the validator - <a href="http://webbylab.github.io/livr-playground" target="_blank" rel="external">http://webbylab.github.io/livr-playground</a>.</p>
<p>The key idea was that the core of the validator should be minimalistic, the whole logic validation rules (or rather their implementation). That is, there is no difference between a validator rules “required” (checks for values), “max_length” (check the maximum length), “to_lc” (cites lowercase), “list_of_objects” (helps to describe the rules for the field, which contains an array of objects).</p>
<p>Ключевой идеей было то, что ядро валидатора должно быть минимальным, а вся логика валидации находится в правилах (вернее в их реализации). То есть, для валидатора нет разницы между правилами “required” (проверяет наличие значения), “max_length” (проверяет максимальную длину), “to_lc” (приводит данные в нижний регистра), “list_of_objects” (помогает описать правила для поля, которое содержит массив объектов). </p>
<p>Другими словами, валидатор ничего не знает ничего:</p>
<ul>
<li>о кодах ошибок</li>
<li>о том, что он умеет валидировать иерархические объекты</li>
<li>о том, что он умеет преобразовывать/чистить данные</li>
<li>о многом другом<br>Все это ответственность правил валидации.</li>
</ul>
<h2 id="Спецификация_LIVR">Спецификация LIVR</h2><p>Поскольку задача стояла сделать валидатор независимым от языка программирования, этакий себе mustache/handlebars, но только в мире валидации данных, то начали мы с написания спецификации.</p>
<p>Цели спецификации:</p>
<ul>
<li>Стандартизировать формат описания данных.</li>
<li>Описать минимальный набор правил валидации, которые должны поддерживаться каждой реализацией.</li>
<li>Стандартизировать коды ошибок.</li>
<li>Быть единой базовой документацией для всех реализаций. </li>
<li>Иметь набор тестовых данных, которые позволяет проверить реализацию на соответствие спецификации<br>Спецификация доступна по адресу <a href="http://livr-spec.org" target="_blank" rel="external">http://livr-spec.org</a></li>
</ul>
<p>Основной идеей было то, что описание правил валидации должно выглядеть, как схема данных и максимально быть похожими на данные, только вместо значений правила. </p>
<p>Пример описания правил валидации для формы авторизации (<a href="http://webbylab.github.io/livr-playground/#%7B%22rules%22%3A%22%7B%5Cn%20%20%20%20email%3A%20%5B&#39;required&#39;%2C%20&#39;email&#39;%5D%2C%5Cn%20%20%20%20password%3A%20&#39;required&#39;%5Cn%7D%22%2C%22data%22%3A%22%7B%5Cn%20%20%20%20email%3A%20&#39;user%40mail.com&#39;%2C%5Cn%20%20%20%20password%3A%20&#39;qwerty123&#39;%5Cn%7D%22%7D" target="_blank" rel="external">demo</a>):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    email: [<span class="string">'required'</span>, <span class="string">'email'</span>],</span><br><span class="line">    password: <span class="string">'required'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Пример правил валидации для регистрационной формы (<a href="http://webbylab.github.io/livr-playground/#%7B%22rules%22%3A%22%7B%5Cn%20%20%20%20name%3A%20&#39;required&#39;%2C%5Cn%20%20%20%20email%3A%20%5B&#39;required&#39;%2C%20&#39;email&#39;%5D%2C%5Cn%20%20%20%20gender%3A%20%7B%20one_of%3A%20%5B&#39;male&#39;%2C%20&#39;female&#39;%5D%20%7D%2C%5Cn%20%20%20%20phone%3A%20%7Bmax_length%3A%2010%7D%2C%5Cn%20%20%20%20password%3A%20%5B&#39;required&#39;%2C%20%7Bmin_length%3A%2010%7D%20%5D%2C%5Cn%20%20%20%20password2%3A%20%7B%20equal_to_field%3A%20&#39;password&#39;%20%7D%5Cn%7D%22%2C%22data%22%3A%22%7B%5Cn%20%20%20%20name%3A%20&#39;John&#39;%2C%5Cn%20%20%20%20email%3A%20&#39;john%40mail.com&#39;%2C%5Cn%20%20%20%20gender%3A%20&#39;male&#39;%2C%5Cn%20%20%20%20phone%3A%20&#39;%2B22221212&#39;%2C%5Cn%20%20%20%20password%3A%20&#39;mypassword1&#39;%2C%5Cn%20%20%20%20password2%3A%20&#39;mypassword1&#39;%5Cn%7D%22%7D" target="_blank" rel="external">demo</a>):<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: <span class="string">'required'</span>,</span><br><span class="line">    email: [<span class="string">'required'</span>, <span class="string">'email'</span>],</span><br><span class="line">    gender: &#123; one_of: [<span class="string">'male'</span>, <span class="string">'female'</span>] &#125;,</span><br><span class="line">    phone: &#123;max_length: <span class="number">10</span>&#125;,</span><br><span class="line">    password: [<span class="string">'required'</span>, &#123;min_length: <span class="number">10</span>&#125; ]</span><br><span class="line">    password2: &#123; equal_to_field: <span class="string">'password'</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Пример валидации вложенного объекта (<a href="http://webbylab.github.io/livr-playground/#%7B%22rules%22%3A%22%7B%5Cn%20%20%20%20name%3A%20'required'%2C%5Cn%20%20%20%20email%3A%20%5B'required'%2C%20'email'%5D%2C%5Cn%20%20%20%20gender%3A%20%7B%20one_of%3A%20%5B'male'%2C%20'female'%5D%20%7D%2C%5Cn%20%20%20%20phone%3A%20%7Bmax_length%3A%2010%7D%2C%5Cn%20%20%20%20password%3A%20%5B'required'%2C%20%7Bmin_length%3A%2010%7D%20%5D%2C%5Cn%20%20%20%20password2%3A%20%7B%20equal_to_field%3A%20'password'%20%7D%5Cn%7D%22%2C%22data%22%3A%22%7B%5Cn%20%20%20%20name%3A%20'John'%2C%5Cn%20%20%20%20email%3A%20'john%40mail.com'%2C%5Cn%20%20%20%20gender%3A%20'male'%2C%5Cn%20%20%20%20phone%3A%20'%2B22221212'%2C%5Cn%20%20%20%20password%3A%20'mypassword1'%2C%5Cn%20%20%20%20password2%3A%20'mypassword1'%5Cn%7D%22%7D" target="_blank" rel="external">демо</a>):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: <span class="string">'required'</span>,</span><br><span class="line">    phone: &#123;max_length: <span class="number">10</span>&#125;,</span><br><span class="line">    address: &#123; <span class="string">'nested_object'</span>: &#123;</span><br><span class="line">        city: <span class="string">'required'</span>,</span><br><span class="line">        zip: [<span class="string">'required'</span>, <span class="string">'positive_integer'</span>]</span><br><span class="line">    &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Правила_валидации">Правила валидации</h2><p>Как описываются правила валиции? Каждое правило состоит из имени и аргументов (практически, как вызов функции) и в общем случае описывается следующим образом {“RULE_NAME”: ARRAY_OF_ARGUMENTS}. Для каждого поля описывается массив правил, которые применяются в порядке следования.</p>
<p>Например,<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"login"</span>: [ &#123; length_between: [ <span class="number">5</span>, <span class="number">10</span> ] &#125; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>То есть, у нас есть поле “login” и правило “length_between”, которое имеет 2 аргумента ( “5” и “10” ).  Это наиболее полная форма, но разрешены следующие упрощения</p>
<ul><br>    <li>Если правило к полю одно, то массив не обязателен</li><br>    <li>Если у правила один аргумент, то можно передавать только его (не обрамляя в массив)</li><br>    <li>Если у правила не аргументов, то можно записать просто название правила.</li><br></ul><br>Все 3 записи идентичны:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"login"</span>: [ &#123; required: [] &#125; ]</span><br></pre></td></tr></table></figure><br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"login"</span>: [ <span class="string">"required"</span> ]</span><br></pre></td></tr></table></figure><br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"login"</span>: <span class="string">"required"</span></span><br></pre></td></tr></table></figure><br><br>Более детально расписано в спецификации в разделе “How it works”.<br><br><strong>Поддерживаемые правила</strong><br><br>Все правила можно разделить на 3 глобальных группы:<br><ul><br>    <li>Правила, которые валидируют данные (числа, строки и тд). Например, “max_length”.</li><br>    <li>Правила, которые позволяют составлять более сложные правила с более простых. Например, “nested_object”.</li><br>    <li>Правила, которые преобразовывают данные. Например, “to_lc” </li><br></ul><br>но сам валидатор не делает различия между ними, для него они все равноправны.<br><br>Вот общий список правил, которые должны поддерживаться каждой реализаций валидатора:<br><br><u>Базовые правила</u><br><ul><br>    <li>required - поле обязательно и значение должно быть не пустым </li><br>    <li>not_empty - поле не обязательно, но если оно есть, то не может быть пустым</li><br>    <li>not_empty_list - значение должно содержать не пустой массив</li><br></ul><br><u>Правила для проверки строк</u><br><ul><br>    <li>one_of </li><br>    <li>max_length</li><br>    <li>min_length</li><br>    <li>length_between</li><br>    <li>length_equal</li><br>    <li>like</li><br></ul><br><u>Правила для проверки чисел</u><br><ul><br>    <li>integer</li><br>    <li>positive_integer</li><br>    <li>decimal</li><br>    <li>positive_decimal</li><br>    <li>max_number</li><br>    <li>min_number</li><br>    <li>number_between</li><br></ul><br><u>Правила для специальных форматов</u><br><ul><br>    <li>email</li><br>    <li>url</li><br>    <li>iso_date</li><br>    <li>equal_to_field</li><br></ul><br><u>Правила для описания более сложных правил (метаправила)</u><br><ul><br>    <li>nested_object - описывает правила для вложенного объекта </li><br>    <li>list_of - описывает правила, которым должен соответствовать каждый элемент списка </li><br>    <li>list_of_objects - значение должно быть массивом объектов нужном формате </li><br>    <li>list_of_different_objects - используйте, когда нужно проверить массив объектов разных типов.</li><br></ul><br>Правила для преобразования данных (названия начинаются с глагола)<br><ul><br>    <li>trim - убирает пробелы в начале в конце</li><br>    <li>to_lc - приводит к нижнему регистру</li><br>    <li>to_uc - приводит к верхнему регистру</li><br>    <li>remove - удаляет указанные символы </li><br>    <li>leave_only - оставляет только указанные символы </li><br></ul><br><strong>Метаправила</strong><br><br>Пример  и коды ошибок для каждого правила можно найти в LIVR-спецификации. Немного детальней остановимся лишь на метаправилах. Метаправила — это правила, которые позволяет скомбинировать простые правила в более сложные для валидации сложных иерархических структур данных. Важно понимать, что валидатор не делает различия между простыми правилами и метаправилами. Метаправила ничем не отличаются от того же “required” (да, я повторяюсь).<br><br><u>nested_object</u><br>Позволяет описывать правила валидации для вложенных объектов. Этим правилом вы будете пользоваться постоянно.<br>Код ошибки зависит от вложенных правил. Если вложенный объект не является хешом (словарем), то поле будет содержать ошибку: “FORMAT_ERROR”.<br>Пример использования (<a href="http://webbylab.github.io/livr-playground/#%7B%22rules%22%3A%22%7B%5Cn%20%20%20%20address%3A%20%7B%20'nested_object'%3A%20%7B%5Cn%20%20%20%20%20%20%20%20city%3A%20'required'%2C%5Cn%20%20%20%20%20%20%20%20zip%3A%20%5B'required'%2C%20'positive_integer'%5D%5Cn%20%20%20%20%7D%7D%5Cn%7D%22%2C%22data%22%3A%22%7B%5Cn%20%20%20%20address%3A%20%7B%5Cn%20%20%20%20%20%20%20%20city%3A%20'Kyiv'%2C%5Cn%20%20%20%20%20%20%20%20zip%3A%201232%5Cn%20%20%20%20%7D%5Cn%7D%22%7D" target="_blank" rel="external">демо</a>):<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">address: &#123; <span class="string">'nested_object'</span>: &#123;</span><br><span class="line">    city: <span class="string">'required'</span>,</span><br><span class="line">    zip: [<span class="string">'required'</span>, <span class="string">'positive_integer'</span>]</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><br><br><u>list_of</u><br>Позволяет описать правила валидации для списка значений. Каждое правило будет применяться для каждого элемента списка.<br>Код ошибки зависит от вложенных правил.<br>Пример использования (<a href="http://webbylab.github.io/livr-playground/#%7B%22rules%22%3A%22%7B%20%5Cn%20%20%20product_ids%3A%20%7B%20'list_of'%3A%20%5B%20'required'%2C%20%20'positive_integer'%5D%7D%5Cn%7D%22%2C%22data%22%3A%22%7B%5Cn%20%20%20%20product_ids%3A%20%5B1%2C2%2C3%2C4%5D%5Cn%7D%22%7D" target="_blank" rel="external">демо</a>):<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; product_ids: &#123; <span class="string">'list_of'</span>: [ <span class="string">'required'</span>,  <span class="string">'positive_integer'</span>] &#125;&#125;</span><br></pre></td></tr></table></figure><br><br><u>list_of_objects</u><br>Позволяет описать правила валидации для массива хешей(словарей). Похоже на “nested_object”, но ожидает массив объектов. Правила применяются для каждого элемента в массиве.<br>Код ошибки зависит от вложенных правил. В случае если значение не является массивом, для поля будет возвращен код “FORMAT_ERROR”.<br>Пример использования (<a href="http://webbylab.github.io/livr-playground/#%7B%22rules%22%3A%22%7B%5Cn%20%20%20%20products%3A%20%5B'required'%2C%20%7B%20'list_of_objects'%3A%20%7B%5Cn%20%20%20%20%20%20%20%20product_id%3A%20%5B'required'%2C'positive_integer'%5D%2C%5Cn%20%20%20%20%20%20%20%20quantity%3A%20%5B'required'%2C%20'positive_integer'%5D%5Cn%20%20%20%20%7D%7D%5D%5Cn%7D%22%2C%22data%22%3A%22%7B%5Cn%20%20%20%20products%3A%20%5B%7B%5Cn%20%20%20%20%20%20%20%20product_id%3A%203455%2C%5Cn%20%20%20%20%20%20%20%20quantity%3A2%5Cn%20%20%20%20%7D%2C%7B%5Cn%20%20%20%20%20%20%20%20product_id%3A%203456%2C%5Cn%20%20%20%20%20%20%20%20quantity%3A3%5Cn%20%20%20%20%7D%5D%5Cn%7D%22%7D" target="_blank" rel="external">демо</a>):<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">products: [<span class="string">'required'</span>, &#123; <span class="string">'list_of_objects'</span>: &#123;</span><br><span class="line">    product_id: [<span class="string">'required'</span>,<span class="string">'positive_integer'</span>],</span><br><span class="line">    quantity: [<span class="string">'required'</span>, <span class="string">'positive_integer'</span>]</span><br><span class="line">&#125;&#125;]</span><br></pre></td></tr></table></figure><br><br><u>list_of_different_objects</u><br>Аналогичен “list_of_objects”, но бывает, что массив, который нам приходит, содержит объекты разного типа. Тип объекта мы можем определить по какому-то полю, например, “type”. “list_of_different_objects” позволяет описать правила для списка объектов разного вида.<br>Код ошибки зависит от вложенных правил валидации. Если вложенных объект не является хешом, то поле будет содержать ошибку “FORMAT_ERROR”.<br>Пример использования (<a href="http://webbylab.github.io/livr-playground/#%7B%22rules%22%3A%22%7B%5Cn%20%20%20%20products%3A%20%5B'required'%2C%20%7B%20'list_of_different_objects'%3A%20%5B%5Cn%20%20%20%20%20%20%20%20product_type%2C%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20material%3A%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20product_type%3A%20'required'%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20material_id%3A%20%5B'required'%2C%20'positive_integer'%5D%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20quantity%3A%20%5B'required'%2C%20%7B'min_number'%3A%201%7D%20%5D%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20warehouse_id%3A%20'positive_integer'%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20service%3A%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20product_type%3A%20'required'%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name%3A%20%5B'required'%2C%20%7B'max_length'%3A%2020%7D%20%5D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%5D%7D%5D%5Cn%7D%22%2C%22data%22%3A%22%7B%5Cn%20%20%20%20products%3A%20%5B%7B%5Cn%20%20%20%20%20%20%20%20product_type%3A%20'material'%2C%5Cn%20%20%20%20%20%20%20%20material_id%3A%20345%2C%5Cn%20%20%20%20%20%20%20%20quantity%3A%20%205%2C%5Cn%20%20%20%20%20%20%20%20warehouse_id%3A%2024%5Cn%20%20%20%20%7D%2C%7B%5Cn%20%20%20%20%20%20%20%20product_type%3A%20'service'%2C%5Cn%20%20%20%20%20%20%20%20name%3A%20'Clean%20filter'%5Cn%20%20%20%20%7D%5D%5Cn%7D%22%7D" target="_blank" rel="external">демо</a>):<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    products: [<span class="string">'required'</span>, &#123; <span class="string">'list_of_different_objects'</span>: [</span><br><span class="line">        product_type, &#123;</span><br><span class="line">            material: &#123;</span><br><span class="line">                product_type: <span class="string">'required'</span>,</span><br><span class="line">                material_id: [<span class="string">'required'</span>, <span class="string">'positive_integer'</span>],</span><br><span class="line">                quantity: [<span class="string">'required'</span>, &#123;<span class="string">'min_number'</span>: <span class="number">1</span>&#125; ],</span><br><span class="line">                warehouse_id: <span class="string">'positive_integer'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            service: &#123;</span><br><span class="line">                product_type: <span class="string">'required'</span>,</span><br><span class="line">                name: [<span class="string">'required'</span>, &#123;<span class="string">'max_length'</span>: <span class="number">20</span>&#125; ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>В этом примере валидатор будут смотреть на “product_type” в каждом хеше и, в завимости от значения этого поля, будет использовать соответствующие правила валидации.<br><br>## Формат ошибок<br><br>Как уже было сказано, правила возвращают строковые коды ошибок, которые понятны разработчику, например, “REQUIRED”, “WRONG_EMAIL”, “WRONG_DATE” и тд. Теперь разработчик может понять, в чем ошибка, осталось удобно донести в каких полях она возникла. Для этого валидатор возвращает структуру аналогичную переданной ему на валидацию, но она содержит только поля в которых возникли ошибки и вместо исходных значений в полях строковые коды ошибок.<br><br>Например, есть правила:<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: <span class="string">'required'</span>,</span><br><span class="line">    phone: &#123;max_length: <span class="number">10</span>&#125;,</span><br><span class="line">    address: &#123; <span class="string">'nested_object'</span>: &#123;</span><br><span class="line">        city: <span class="string">'required'</span>,</span><br><span class="line">        zip: [<span class="string">'required'</span>, <span class="string">'positive_integer'</span>]</span><br><span class="line">    &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>и данные для валидации:<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    phone: <span class="number">12345678901</span>,</span><br><span class="line">    address: &#123;</span><br><span class="line">       city: <span class="string">'NYC'</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>на выходе получим следующую ошибку<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"REQUIRED"</span>,</span><br><span class="line">    <span class="string">"phone"</span>: <span class="string">"TOO_LONG"</span>,</span><br><span class="line">    <span class="string">"address"</span>: &#123;</span><br><span class="line">        <span class="string">"zip"</span>: <span class="string">"REQUIRED"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><a href="http://webbylab.github.io/livr-playground/#%7B%22rules%22%3A%22%7B%5Cn%20%20%20%20name%3A%20'required'%2C%5Cn%20%20%20%20phone%3A%20%7Bmax_length%3A%2010%7D%2C%5Cn%20%20%20%20address%3A%20%7B%20'nested_object'%3A%20%7B%5Cn%20%20%20%20%20%20%20%20city%3A%20'required'%2C%5Cn%20%20%20%20%20%20%20%20zip%3A%20%5B'required'%2C%20'positive_integer'%5D%5Cn%20%20%20%20%7D%7D%5Cn%7D%22%2C%22data%22%3A%22%7B%5Cn%20%20%20%20phone%3A%2012345678901%2C%5Cn%20%20%20%20address%3A%20%7B%5Cn%20%20%20%20%20%20%20city%3A%20'Kiev'%20%5Cn%20%20%20%20%7D%5Cn%7D%22%7D" target="_blank" rel="external"> демо валидации </a><br><br><br>## REST API и формат ошибок<br><br>Возврат вменяемых ошибок всегда требует дополнительных усилий от разработчиков. И очень мало REST API, которые дают детальную информацию в ошибках. Часто это просто “Bad request” и все. Хочется, чтобы глядя на ошибку, к какому полю она относится и просто пути поля недостаточно, поскольку данные могут быть иерархическими и содержать массивы объектов.. У нас в компании мы поступаем следующим образом -  абсолютно для каждого запроса описываем правила валидации при помощи LIVR. В случае ошибки валидации, мы возвращаем объект ошибки клиенту. Объект ошибки содержит глобальный код ошибки и ошибку полученную от LIVR валидатора.<br><br>Например, вы передаете данные на сервер:<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"email"</span>: <span class="string">"user_at_mail_com"</span>,</span><br><span class="line">    <span class="string">"age"</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="string">"address"</span>: &#123;</span><br><span class="line">        <span class="string">"country"</span>: <span class="string">"USQ"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>и в ответ получаете (<a href="http://webbylab.github.io/livr-playground/#%7B%22rules%22%3A%22%7B%5Cn%20%20%20%20%20%20%20%20%5C%22email%5C%22%3A%20%5C%22email%5C%22%2C%5Cn%20%20%20%20%20%20%20%20%5C%22age%5C%22%3A%20%7Bmin_number%3A%2016%7D%2C%5Cn%20%20%20%20%20%20%20%20%5C%22fname%5C%22%3A%20%5C%22required%5C%22%2C%5Cn%20%20%20%20%20%20%20%20%5C%22lname%5C%22%3A%20%5C%22required%5C%22%2C%5Cn%20%20%20%20%20%20%20%20%5C%22address%5C%22%3A%20%20%7Bnested_object%3A%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%5C%22country%5C%22%3A%20%7Bone_of%3A%20%5B'USA'%2C%20'GB'%5D%7D%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%5C%22city%5C%22%3A%20%5C%22required%5C%22%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%5C%22zip%5C%22%3A%20%5C%22required%5C%22%5Cn%20%20%20%20%20%20%20%20%7D%7D%5Cn%20%20%20%20%7D%22%2C%22data%22%3A%22%7B%5Cn%20%20%20%20%5C%22email%5C%22%3A%20%5C%22user_at_mail_com%5C%22%2C%5Cn%20%20%20%20%5C%22age%5C%22%3A%2010%2C%5Cn%20%20%20%20%5C%22address%5C%22%3A%20%7B%5Cn%20%20%20%20%20%20%20%20%5C%22country%5C%22%3A%20%5C%22USQ%5C%22%5Cn%20%20%20%20%7D%5Cn%7D%22%7D" target="_blank" rel="external">демо валидации на livr playground</a>):<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"error"</span>: &#123;</span><br><span class="line">    <span class="string">"code"</span>: <span class="string">"FORMAT_ERROR"</span>,</span><br><span class="line">    <span class="string">"fields"</span>: &#123;</span><br><span class="line">        <span class="string">"email"</span>: <span class="string">"WRONG_EMAIL"</span>,</span><br><span class="line">        <span class="string">"age"</span>: <span class="string">"TOO_LOW"</span>,</span><br><span class="line">        <span class="string">"fname"</span>: <span class="string">"REQUIRED"</span>,</span><br><span class="line">        <span class="string">"lname"</span>: <span class="string">"REQUIRED"</span>,</span><br><span class="line">        <span class="string">"address"</span>:  &#123;</span><br><span class="line">            <span class="string">"country"</span>: <span class="string">"NOT_ALLOWED_VALUE"</span>,</span><br><span class="line">            <span class="string">"city"</span>: <span class="string">"REQUIRED"</span>,</span><br><span class="line">            <span class="string">"zip"</span>: <span class="string">"REQUIRED"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><br><br>Это значительно информативнее, чем какой-то “Bad request”.<br><br><strong>Работа с псевдонимами и регистрация собственных правил</strong><br><br>Спецификация содержит только наиболее используемые правила, но у каждого проекта своя специфика и постоянно возникают ситуации, когда каких-то правил не хватает. В связи с этим, одним из ключевых требований к валидатору была возможность его расширения собственными правилами любого типа. Изначально каждая реализация имела свой механизм описания правил, но начиная со спецификации версии 0.4 мы ввели стандартный способ создания правил на базе других правил (создание псевдонимов), это покрывает 70% ситуаций. Рассмотрим оба варианта.<br><br><u>Создание псевдонима</u><br>Способ, каким регистрируется псевдоним зависит от реализации, но то как псевдоним описывается - регламентировано спецификацией. Такой подход, например, позволяет сериализировать описания псевдонимов и использовать их с разными реализациями (например, на Perl-бекенде и JavaScript-фронтенде)<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Регистрация псевдонима "valid_address"</span></span><br><span class="line">validator. registerAliasedRule(&#123;</span><br><span class="line">    name: <span class="string">'valid_address'</span>,</span><br><span class="line">    rules: &#123; nested_object: &#123;</span><br><span class="line">        country: <span class="string">'required'</span>,</span><br><span class="line">        city: <span class="string">'required'</span>,</span><br><span class="line">        zip: <span class="string">'positive_integer'</span></span><br><span class="line">    &#125;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Регистрация псевдонима "adult_age"</span></span><br><span class="line">validator.registerAliasedRule( &#123;</span><br><span class="line">    name: <span class="string">'adult_age'</span>,</span><br><span class="line">    rules: [ <span class="string">'positive_integer'</span>, &#123; min_number: <span class="number">18</span> &#125; ]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Теперь псевдонимы доступны, как обычные правила.</span></span><br><span class="line">&#123;</span><br><span class="line">    name: <span class="string">'required'</span>,</span><br><span class="line">    age: [<span class="string">'required'</span>, <span class="string">'adult_age'</span> ],</span><br><span class="line">    address: [<span class="string">'required'</span>, <span class="string">'valid_address'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>Более того, можно устанавливать свои коды ошибок для правил.<br><br>Например,<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">validator.registerAliasedRule(&#123;</span><br><span class="line">    name: <span class="string">'valid_address'</span>,</span><br><span class="line">    rules: &#123; nested_object: &#123;</span><br><span class="line">        country: <span class="string">'required'</span>,</span><br><span class="line">        city: <span class="string">'required'</span>,</span><br><span class="line">        zip: <span class="string">'positive_integer'</span></span><br><span class="line">    &#125;&#125;,</span><br><span class="line">    error: <span class="string">'WRONG_ADDRESS'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><br>и в случае ошибки при валидации адреса, мы получим следующее:<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    address: <span class="string">'WRONG_ADDRESS'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><u>Регистрация полноценного правила на примере <a href="https://www.npmjs.com/package/livr" target="_blank" rel="external"> JavaScript реализации </a></u><br>Для валидации используются функции обратного вызова, которые осуществляют проверку значений. Попробуем описать новое правило под названием “strong_password”. Будем проверять, что значение больше 8 символов и содержит цифры и буквы в верхнем и нижнем регистрах.<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> LIVR = <span class="built_in">require</span>(<span class="string">'livr'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rules = &#123;password: [<span class="string">'required'</span>, <span class="string">'strong_password'</span>]&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> validator = <span class="keyword">new</span> LIVR.Validator(rules);</span><br><span class="line"></span><br><span class="line">validator.registerRules(&#123;</span><br><span class="line">    strong_password: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// пропускаем пустые значение. Для проверки на обязательность у нас и так есть правило "required"</span></span><br><span class="line">            <span class="keyword">if</span> (val === <span class="literal">undefined</span> || val === <span class="literal">null</span> || val === <span class="string">''</span> ) <span class="keyword">return</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ( length(val) &lt; <span class="number">8</span> || !val.match([<span class="number">0</span>-<span class="number">9</span>]) || !val.match([a-z] || !val.match([A-Z] ) ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'WEAK_PASSWORD'</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><br>Теперь добавим возможность задавать минимальное количество символов в пароле и зарегистрируем это правило как глобальное (доступное во всех экземплярах валидатора).<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> LIVR = <span class="built_in">require</span>(<span class="string">'livr'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rules = &#123;password: [<span class="string">'required'</span>, &#123;<span class="string">'strong_password'</span>: <span class="number">10</span>&#125;]&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> validator = <span class="keyword">new</span> LIVR.Validator(rules);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> strongPassword = <span class="function"><span class="keyword">function</span>(<span class="params">minLength</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!minLength) <span class="keyword">throw</span> <span class="string">"[minLength] parameter required"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// пропускаем пустые значение. Для проверки на обязательность у нас и так есть правило "required"</span></span><br><span class="line">        <span class="keyword">if</span> (val === <span class="literal">undefined</span> || val === <span class="literal">null</span> || val === <span class="string">''</span> ) <span class="keyword">return</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> ( length(val) &lt; minLength || !val.match([<span class="number">0</span>-<span class="number">9</span>]) || !val.match([a-z] || !val.match([A-Z] ) ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'WEAK_PASSWORD'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LIVR.Validator.registerDefaultRules(&#123; strong_password: strongPassword &#125;);</span><br></pre></td></tr></table></figure><br><br>Вот так, достаточно просто, происходит регистрация новых правил. Если необходимо описать более сложные правила, то лучшим вариантом будет посмотреть список стандартных правил, реализованных в валидаторе:<br><ul><br>    <li><a href="https://github.com/koorchik/js-validator-livr/blob/master/lib/LIVR/Rules/Common.js" target="_blank" rel="external">Common</a></li><br>    <li><a href="https://github.com/koorchik/js-validator-livr/blob/master/lib/LIVR/Rules/Numeric.js" target="_blank" rel="external">Numeric</a></li><br>    <li><a href="https://github.com/koorchik/js-validator-livr/blob/master/lib/LIVR/Rules/String.js" target="_blank" rel="external">String</a></li><br>    <li><a href="https://github.com/koorchik/js-validator-livr/blob/master/lib/LIVR/Rules/Special.js" target="_blank" rel="external">Special</a></li><br>    <li><a href="https://github.com/koorchik/js-validator-livr/blob/master/lib/LIVR/Rules/Helpers.js" target="_blank" rel="external">Helpers</a></li><br>    <li><a href="https://github.com/koorchik/js-validator-livr/blob/master/lib/LIVR/Rules/Filters.js" target="_blank" rel="external">Filters</a></li><br></ul><br>Есть возможность регистрации правил, которые будут не только валидировать значение, но и изменять его. Например, приводить к верхнему регистру или удалять лишние пробелы.<br><br><strong>Своя реализация по спецификации</strong><br><br>Если есть желание сделать свою реализацию валидатора, то для облегчения задачи был создан набор <a href="https://github.com/koorchik/LIVR/tree/master/test_suite" target="_blank" rel="external"> тест-кейсов </a> . Если ваша реализация проходит все тесты, то ее можно считать корректной. Комплект тестов состоит из 4-х групп:<br><br><ul><br>    <li> “positive” - позитивные тесты для основных правил </li><br>    <li> “negative” - негативные тесты для основных правил </li><br>    <li> “aliases_positive” - позитивные тесты для псевдонимов правил </li><br>    <li> “aliases_negative” - негативные тесты для псевдонимов правил </li><br></ul><br>По сути, каждый тест содержит несколько файлов:<br><br><ul><br>    <li> rules.json — описание правил валидации </li><br>    <li> input.json — структура, которая передается валидатору на проверку </li><br>    <li> output.json — очищенная структура, которая получается после валидации </li><br></ul><br>Каждый негативный тест вместо “output.json” содержит “errors.json” с описанием ошибки, которая должна возникнуть в результате валидации. В тестах псевдонимов есть файл “aliases.json” с псевдонимами, которые необходимо предварительно зарегистрировать.<br><br><strong>Почему не JSON Schema? </strong><br><br>Часто задаваемый вопрос. Если коротко, то причин несколько:<br><ul><br>    <li>Сложный формат для правил. Хочется, чтобы структура с правилами была максимально близка к структуре с данными. Попробуйте описать <a href="http://webbylab.github.io/livr-playground/#%7B%22rules%22%3A%22%7B%5Cn%20%20%20%20order_id%3A%20%5B'required'%2C%20'positive_integer'%5D%2C%5Cn%20%20%20%20product_ids%3A%20%5B%7B%5Cn%20%20%20%20%20%20%20'list_of'%3A%20%5B%20'required'%2C%20%20'positive_integer'%20%5D%5Cn%20%20%20%20%7D%5D%5Cn%7D%22%2C%22data%22%3A%22%7B%5Cn%20%20%20%20order_id%3A%2010455%2C%5Cn%20%20%20%20product_ids%3A%20%5B3455%2C%203456%2C%203566%5D%5Cn%7D%22%7D" target="_blank" rel="external">этот пример</a> на JSON Schema</li><br>    <li>Формат ошибок никак не специфицирован и разные реализации возвращают ошибки в разном формате.</li><br>    <li>Нет преобразования данных, например “to_lc”.</li><br></ul><br>JSON Schema содержит и интересные вещи, как-то возможность задать максимальное количество элементов в списке, но в LIVR это реализуется просто добавлением еще одного правила.<br><br><strong>Ссылки по LIVR</strong><br><br><ul><br>    <li><a href="http://livr-spec.org" target="_blank" rel="external">Спецификация LIVR (последняя версия - 0.4)</a></li><br>    <li><a href="https://github.com/koorchik/LIVR/tree/master/test_suite" target="_blank" rel="external">Комплект тестов</a></li><br>        <li><a href="http://webbylab.github.io/livr-playground/" target="_blank" rel="external">LIVR Playground</a></li><br>    <li><a href="https://www.npmjs.com/package/livr" target="_blank" rel="external">JavaScript реализация</a></li><br>    <li><a href="https://metacpan.org/pod/Validator::LIVR" target="_blank" rel="external">Perl реализация</a></li><br>    <li><a href="https://github.com/WebbyLab/php-validator-livr" target="_blank" rel="external">PHP реализация</a></li><br>    <li><a href="https://pypi.python.org/pypi/LIVR" target="_blank" rel="external">Python реализация</a></li><br>    <li><a href="http://pragmaticperl.com/issues/05/pragmaticperl-05-livr-language-independent-validation-rules-%D0%BD%D0%B5%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D1%8B%D0%B5-%D0%BE%D1%82-%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0-%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0-%D0%B2%D0%B0%D0%BB%D0%B8%D0%B4%D0%B0%D1%86%D0%B8%D0%B8.html" target="_blank" rel="external"> Статья про LIVR и Perl реализацию в журнале PragmaticPerl</a></li><br>    <li><a href="https://vimeo.com/76611833" target="_blank" rel="external">Видео доклада про LIVR на конференции OSDN-UA 2013</a></li><br></ul>]]></content>
    <summary type="html">
    <![CDATA[<p>Every programmer faced the need to validate user input. Doing web development for over 10 years, I have tried a lot of libraries, but did]]>
    </summary>
    
      <category term="JavaScript" scheme="http://blog.koorchik.com/tags/JavaScript/"/>
    
      <category term="PHP" scheme="http://blog.koorchik.com/tags/PHP/"/>
    
      <category term="Perl" scheme="http://blog.koorchik.com/tags/Perl/"/>
    
      <category term="Python" scheme="http://blog.koorchik.com/tags/Python/"/>
    
      <category term="Validation" scheme="http://blog.koorchik.com/tags/Validation/"/>
    
  </entry>
  
</feed>